---
layout: post
title: Testing MathJax
tags: mathjax
math: true
date: 2025-10-07 16:45 +0800
---

目录：

## 环境配置

### 1.1查看电脑情况

深度学习对电脑有一定的性能要求，建议使用NVIDIA独立显卡在cuda环境进行GPU训练，在windows环境下我们可以使用以下命令查看电脑的NVIDIA显卡来查看电脑支持的支持情况。
$
 nvidia-smi
$
我当前的显卡支持cuda12.6版本，那么接下来我们需要来到英伟达显卡官网来下载所需要的cuda
### 1.2下载cuda和cudnn
#### 1.2.1安装cuda
我们可以直接来到浏览器，搜索cuda12.6或你的显卡所能支持的对应的cuda版本

在官网选择我们需要的版本，下载并安装


安装完成后可以再次在cmd里输入：
$
nvcc -V
$
显示版本号即安装成功


#### 1.2.2安装cudnn
进入cudnn官网，选择合适版本的文件
cuDNN官网地址：
下载时需登录英伟达账户，下载后将得到的压缩包内文件解压至电脑的cuda的文件夹中进行覆盖替换，替换完成后即cudnn安装完成。按照本文教程安装的cuda的文件夹默认在 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.6 目录下


安装conda虚拟环境，conda可以方便的管理python虚拟环境和深度学习，有完整版的annaconda和简洁的miniconda，我们在这里选择miniconda即可


防止出现其他问题，我们选择默认安装位置即可

在选择时我们把conda加入环境变量防止Visual Studio Code或其他命令行无法正常使用conda

来到cmd的命令行输入来创建一个名为yolo11，python环境3.10的conda虚拟环境，给出的选项选择a和y即可

输入即可查看当前拥有的所有conda环境

#### 1.2.3安装pytorch
首先进入新建的conda环境，conda activate yolo11

接着来到pytorch的官网，使用官方提供的命令和自身cuda版本进行pytorch的安装
我的cuda是cuda12.6因此选择12.6的安装命令并复制

将安装命令输入在conda环境中等待下载完成


### 1.3安装ultralytics和yolo11的源码
使用直接安装ultralytics，ultralytics库中有我们训练和推理模型时所需的所有命令，可以直接使用pip安装

安装结束后可以进入github下载yolo11的源码，点击下载压缩包，下载完成后解压至任意文件夹下

打开Visual Studio Code，在左侧插件商店中搜索并安装python的扩展


然后在左上角选择并打开刚才所下载解压的ultralytics源代码

随便点击一个其中的python文件，然后在右下角点击选择python解释器为我们创建的yolo11虚拟环境
下面为了测试环境和训练模型，需要从github下载官方的权重文件并放置在项目根目录，
同时我们可以从互联网或个人拍照，将一张图像放入项目的根目录并且新建一个py文件进行环境测试，文件的内容如下：
$
from ultralytics import YOLO # 加载预训练的 YOLOv11n 模型
model = YOLO('yolo11n.pt')
source = 'dog.png' #更改为自己的图片
$
# 运行推理，并附加参数
$
model.predict(source, save=True)
$

下面点击右上角运行python文件

下面根据日志，代码正常运行，同时测试的结果被输出在了项目的runs\detect\predict目录中


## 数据集与模型训练

### 2.1数据集制作
数据集可以使用网上公开的的数据集，或者是搜索/拍摄自己研究所需要的图片进行标注制作成数据集，我们这里直接使用个人拍摄到的图像来自己制作数据集。
#### 2.1.1labelimg工具标注数据
在conda环境中输入安装labelimg工具，用于标注，使用labelimg之前，需要准备好数据集存放位置。这里创建一个data文件夹，在这里面创建文件夹images、labels和文件classes.txt，其中images文件夹里面放所有的图片，labels文件夹是将会用来对标签文件存放，classes.txt里存放所有的类别，每种一行.


根据我们本次要制作的数据集，classes.txt内的标签应当是helmet、nohelmet、reflective、noreflective。在准备好后，我们来到data文件夹，然后输入
打开labelimg,选择保存模式为yolo，点击Change Save Dir，选择labels作为存放标注文件的目录。点击w切换为十字标进行标注，按D键切换下一张图，成功标注后的标签显示在软件右侧

标注完成过后点击关闭软件，选择yes保存

#### 2.1.2使用代码进行数据划分
数据集在标注后还需要进行数据划分，分为训练集，验证集和测试集，我们使用代码按照8：1：1的比例进行划分，代码如下 
$
import os
import shutil
import random

# random.seed(0) #随机种子，可自选开启

def split_data(file_path, label_path, new_file_path, train_rate, val_rate, test_rate):
images = os.listdir(file_path)
labels = os.listdir(label_path)
images_no_ext = {os.path.splitext(image)[0]: image for image in images}
labels_no_ext = {os.path.splitext(label)[0]: label for label in labels}
matched_data = [(img, images_no_ext[img], labels_no_ext[img]) for img in images_no_ext if img in labels_no_ext]

unmatched_images = [img for img in images_no_ext if img not in labels_no_ext]
unmatched_labels = [label for label in labels_no_ext if label not in images_no_ext]
if unmatched_images:
print("未匹配的图片文件:")
for img in unmatched_images:
print(images_no_ext[img])
if unmatched_labels:
print("未匹配的标签文件:")
for label in unmatched_labels:
print(labels_no_ext[label])

random.shuffle(matched_data)
total = len(matched_data)
train_data = matched_data[:int(train_rate * total)]
val_data = matched_data[int(train_rate * total):int((train_rate + val_rate) * total)]
test_data = matched_data[int((train_rate + val_rate) * total):]

# 处理训练集
for img_name, img_file, label_file in train_data:
old_img_path = os.path.join(file_path, img_file)
old_label_path = os.path.join(label_path, label_file)
new_img_dir = os.path.join(new_file_path, 'train', 'images')
new_label_dir = os.path.join(new_file_path, 'train', 'labels')
os.makedirs(new_img_dir, exist_ok=True)
os.makedirs(new_label_dir, exist_ok=True)
shutil.copy(old_img_path, os.path.join(new_img_dir, img_file))
shutil.copy(old_label_path, os.path.join(new_label_dir, label_file))
# 处理验证集
for img_name, img_file, label_file in val_data:
old_img_path = os.path.join(file_path, img_file)
old_label_path = os.path.join(label_path, label_file)
new_img_dir = os.path.join(new_file_path, 'val', 'images')
new_label_dir = os.path.join(new_file_path, 'val', 'labels')
os.makedirs(new_img_dir, exist_ok=True)
os.makedirs(new_label_dir, exist_ok=True)
shutil.copy(old_img_path, os.path.join(new_img_dir, img_file))
shutil.copy(old_label_path, os.path.join(new_label_dir, label_file))
# 处理测试集
for img_name, img_file, label_file in test_data:
old_img_path = os.path.join(file_path, img_file)
old_label_path = os.path.join(label_path, label_file)
new_img_dir = os.path.join(new_file_path, 'test', 'images')
new_label_dir = os.path.join(new_file_path, 'test', 'labels')
os.makedirs(new_img_dir, exist_ok=True)
os.makedirs(new_label_dir, exist_ok=True)
shutil.copy(old_img_path, os.path.join(new_img_dir, img_file))
shutil.copy(old_label_path, os.path.join(new_label_dir, label_file))
print("数据集已划分完成")

if __name__ == '__main__':
file_path = r"data/images" # 图片文件夹
label_path = r'data/labels' # 标签文件夹
new_file_path = r"VOCdevkit" # 新数据存放位置
split_data(file_path, label_path, new_file_path, train_rate=0.8, val_rate=0.1, test_rate=0.1)
$

我其中的文件路径需要确定为自己的实际路径，这里将python脚本直接放在data文件夹内并运行

生成的文件夹内容如图

其中分别是测试集，训练集和验证集。此时数据集准备完毕了。

### 2.2模型训练
#### 2.2.1模型配置
新建配置文件，配置文件是yaml格式，可以叫任何名字，我选择放在项目的根目录下，并起名为my_yolo11.yaml然后将数据集也复制到项目的根目录。现在项目结构如下
配置文件内容如图 
$
train: VOCdevkit/train/images # 训练集路径
val: VOCdevkit/val/images # 验证集路径
test: VOCdevkit/test/images # 测试集路径
$
# 训练参数
$
nc: 4 # 类别数

# Classes
names: ['helmet',
'nohelmet',
'reflective',
'noreflective'] # 标签名称
$
#### 2.2.2训练脚本
在准备好以上文件后，我们新建一个python文件来训练模型 。
直接在项目的根目录中新建一个python文件，这里我新建名为go_and_run.py的文件，写入如下内容，其中.pt权重文件我们使用了在测试环境时下载的yolo11n模型，因此无需再下载，model同样选择与之对应的yolo11n.yaml，如需训练其他模型需要替换为对应的文件。
$
import warnings
warnings.filterwarnings('ignore')
from ultralytics import YOLO
if __name__ == '__main__':
model = YOLO('ultralytics/cfg/models/11/yolo11n.yaml')
model.load('yolo11n.pt') #选择的官方权重模型，注释则不加载
results = model.train(
data='my.yolo11.yaml', #数据集配置文件的路径
epochs=200, #训练轮次总数
batch=16, #批量大小，即单次输入多少图片训练
imgsz=640, #训练图像尺寸
workers=8, #加载数据的工作线程数
device= 0, #指定训练的计算设备，无nvidia显卡则改为 'cpu'
optimizer='SGD', #训练使用优化器，可选 auto,SGD,Adam,AdamW 等
amp= True, #True 或者 False, 解释为：自动混合精度(AMP) 训练
cache=False # True 在内存中缓存数据集图像，服务器推荐开启
)
如果出现错误是训练集错误请往下翻有修复教程，如果没有请继续。
这里用哪个模型对应哪个yaml，如果使用yolov11s.pt则对应yolo11s.yaml
epochs是训练轮数，可以由少变多看训练效果，workers和batch根据电脑性能进行调整，如果运行吃力则相应降低，最好为2的n次方。没有显卡则把device=0修改为device='cpu'。
本文使用的是yolo11n.pt
确认以上代码的配置和路径均为自己的路径后运行代码，耐心等待训练完成
代码运行结束后根据日志，可以看出最终模型训练的路径

其中的best.pt就是我们最终训练得到的模型
#### 2.2.3模型测试
找到之前训练的结果保存路径，创建一个yolov11_predict.py文件，内容如下
from ultralytics import YOLO
# 加载训练好的模型，改为自己的路径
model = YOLO('runs/detect/train/weights/best.pt') #修改为训练好的路径
source = 'test1.jpg' #修改为自己的图片路径及文件名
# 运行推理，并附加参数
model.predict(source, save=True)
运行后就会得到预测模型结果

后面的路径就是预测的图片，可以查看标签是否正确。那么恭喜你的模型训练好了，如果不正确请返回labelimg中查看自己标签是否正确。
试集上推理模型精度代码如下，可新增v11_val.py，输入下方代码，更改模型路径及数据集路径即可。
import warnings
warnings.filterwarnings('ignore')
from ultralytics import YOLO
if __name__ == '__main__':
model = YOLO('runs/detect/train/weights/best.pt') #修改为自己训练的模型路径
model.val(data='hat.yaml', #修改为自己的数据集yaml文件
split='test',
imgsz=640,
batch=16,
iou=0.6, #阈值可以改，mAP50为0.5的情况下
conf=0.001,
workers=8,
)
运行后即出现测试集上各类别的精度及总体精度。
$

## 3.可能出现的问题
### 3.1conda相关
#### 3.1.1conda环境安装慢
由于默认的环境都是从国外服务器获取的资源，因此可能会有下载速度慢的问题，当出现这种情况的时候，可以切换国内源来提高下载速度，例如 
$
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --set show_channel_urls yes
conda clean -i
$
3.1.2conda在vscode中无法正常使用 conda环境无法在vscode中正常使用，提示类似于无法将“conda”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。所在位置 行:1 字符: 1+ con这样的提示


请卸载并重新安装conda，在安装时确保选择了“仅为我安装“以及确定选择了添加conda进入环境变量。


### 3.2训练相关
#### 3.2.1训练的问题
# （1）训练速度的同时CPU/显卡/内存占用低/内存不足
在上述的训练脚本中，我们有一项cache=False，这一项为Ture时会在内存中缓存数据集图像，通常对个人电脑有更高的性能需求，更推荐服务器开启。
（2）如果是在显卡内存都占用高的情况下训练速度慢，建议检查指定参数的大小，epochs，imgsz，batch，workers四个选项，分别代表了训练总轮数，图像尺寸，单次处理图像数量和使用的线程数，CPU有空闲的状态下可以尝试适当增大workers的数值，多线程以提高处理速度，但是无论增大哪一项数值都需要更高的算力。这里更推荐考虑项目本身和模型精度，适当减少训练轮次和训练的数据集数量，因为当数据集数量过多时，可能会造成模型训练过程中的处理速度慢且难以增强模型的精度。因此建议根据需求适当减少参数或者租用服务器进行训练达到事半功倍的效果。
